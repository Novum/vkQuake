#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

// Compute shader for skeletal skinning of MD5 model vertices
// for acceleration structure building.
//
// Input: md5vert_t vertex data, joint matrices
// Output: skinned vec3 positions

layout (push_constant) uniform PushConsts
{
	uint  joints_offset0;  // Joint matrix offset for pose 0
	uint  joints_offset1;  // Joint matrix offset for pose 1
	uint  output_offset;   // Offset in output buffer (in floats)
	uint  num_verts;
	float blend_factor;
}
push_constants;

// md5vert_t layout:
// float xyz[3]           - 12 bytes (offset 0)
// float norm[3]          - 12 bytes (offset 12)
// float st[2]            - 8 bytes  (offset 24)
// byte joint_weights[4]  - 4 bytes  (offset 32)
// byte joint_indices[4]  - 4 bytes  (offset 36)
// Total: 40 bytes = 10 floats

layout (std430, set = 0, binding = 0) restrict readonly buffer InputVertices
{
	float vertex_data[];
};

layout (std430, set = 0, binding = 1) restrict readonly buffer JointMatrices
{
	float joint_mats[];
};

layout (std430, set = 0, binding = 2) restrict writeonly buffer OutputPositions
{
	float positions[];
};

// Load a 3x4 joint matrix and transform a position
vec3 transform_by_joint (vec3 pos, uint joint_offset)
{
	uint base = joint_offset * 12;
	mat4x3 m = mat4x3 (
		joint_mats[base + 0], joint_mats[base + 4], joint_mats[base + 8],
		joint_mats[base + 1], joint_mats[base + 5], joint_mats[base + 9],
		joint_mats[base + 2], joint_mats[base + 6], joint_mats[base + 10],
		joint_mats[base + 3], joint_mats[base + 7], joint_mats[base + 11]
	);
	return (m * vec4 (pos, 1.0)).xyz;
}

layout (local_size_x = 64, local_size_y = 1) in;
void main ()
{
	uint vertex_idx = gl_GlobalInvocationID.x;
	if (vertex_idx >= push_constants.num_verts)
		return;

	// Read vertex data (40 bytes = 10 floats per vertex)
	uint base = vertex_idx * 10;
	vec3 bind_pos = vec3 (vertex_data[base + 0], vertex_data[base + 1], vertex_data[base + 2]);

	// Joint weights and indices are packed as bytes at offset 32 and 36
	// That's floats 8 and 9 in our float array
	uint weights_packed = floatBitsToUint (vertex_data[base + 8]);
	uint indices_packed = floatBitsToUint (vertex_data[base + 9]);

	// Extract weights (normalized bytes)
	vec4 weights = vec4 (
		float (weights_packed & 0xFF),
		float ((weights_packed >> 8) & 0xFF),
		float ((weights_packed >> 16) & 0xFF),
		float ((weights_packed >> 24) & 0xFF)
	) / 255.0;

	// Extract joint indices
	uvec4 indices = uvec4 (
		indices_packed & 0xFF,
		(indices_packed >> 8) & 0xFF,
		(indices_packed >> 16) & 0xFF,
		(indices_packed >> 24) & 0xFF
	);

	// Skin for both animation frames
	vec3 skinned_pos[2] = vec3[2](vec3 (0.0), vec3 (0.0));
	uint joint_offsets[2] = uint[2](push_constants.joints_offset0, push_constants.joints_offset1);

	for (int frame = 0; frame < 2; ++frame)
	{
		uint frame_offset = joint_offsets[frame];
		for (int i = 0; i < 4; ++i)
		{
			float weight = weights[i];
			if (weight > 0.0)
			{
				uint joint_idx = indices[i];
				skinned_pos[frame] += weight * transform_by_joint (bind_pos, frame_offset + joint_idx);
			}
		}
	}

	// Interpolate between frames
	vec3 lerped = mix (skinned_pos[0], skinned_pos[1], push_constants.blend_factor);

	// Write output
	uint out_idx = push_constants.output_offset + vertex_idx * 3;
	positions[out_idx + 0] = lerped.x;
	positions[out_idx + 1] = lerped.y;
	positions[out_idx + 2] = lerped.z;
}
