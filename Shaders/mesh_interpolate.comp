#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference_uvec2 : require

// Compute shader for interpolating alias model vertices (MDL/MD3)
// for acceleration structure building.
//
// Input: meshxyz_t vertex data (uint16 xyz[4] + int8 normal[4] = 12 bytes per vertex)
// Output: interpolated vec3 positions in model space
//
// The TLAS instance transform handles scale_origin, scale, and entity transform.

layout (buffer_reference, std430) readonly buffer InputVertexBuffer
{
	uint data[];
};
layout (buffer_reference, std430) writeonly buffer OutputBuffer
{
	float data[];
};

layout (push_constant) uniform PushConsts
{
	uvec2 input_address;  // 0
	uvec2 output_address; // 8
	uint  pose1_offset;	  // 16
	uint  pose2_offset;	  // 20
	uint  output_offset;  // 24
	uint  num_verts;	  // 28
	float blend_factor;	  // 32
	uint  flags;		  // 36 (Bit 2: MD3 format)
}
push_constants;

// Decode a meshxyz_t vertex position to model-space coordinates
vec3 decode_vertex (InputVertexBuffer input_buffer, uint offset)
{
	// Each meshxyz_t is 12 bytes = 3 uints
	// First 8 bytes (2 uints) contain xyz[4] as uint16
	uint xyz_low = input_buffer.data[offset * 3];
	uint xyz_high = input_buffer.data[offset * 3 + 1];

	// Extract uint16 values
	float x = float (xyz_low & 0xFFFF);
	float y = float (xyz_low >> 16);
	float z = float (xyz_high & 0xFFFF);

	// Normalize to [0, 1] then convert to model-space format
	const float norm = 1.0 / 65535.0;
	vec3		pos = vec3 (x, y, z) * norm;

	if ((push_constants.flags & 0x4) != 0)
	{
		// MD3: [0,1] -> [-32768, 32767] (raw format)
		pos = pos * 65535.0 - 32768.0;
	}
	else
	{
		// MDL: [0,1] -> [0, 255] (raw trivertx values)
		pos = pos * 255.0;
	}

	return pos;
}

layout (local_size_x = 64, local_size_y = 1) in;
void main ()
{
	uint vertex_idx = gl_GlobalInvocationID.x;
	if (vertex_idx >= push_constants.num_verts)
		return;

	InputVertexBuffer input_buffer = InputVertexBuffer (push_constants.input_address);
	OutputBuffer	  output_buffer = OutputBuffer (push_constants.output_address);

	vec3 pos1 = decode_vertex (input_buffer, push_constants.pose1_offset + vertex_idx);
	vec3 pos2 = decode_vertex (input_buffer, push_constants.pose2_offset + vertex_idx);

	vec3 lerped = mix (pos1, pos2, push_constants.blend_factor);

	uint out_idx = push_constants.output_offset + vertex_idx * 3;
	output_buffer.data[out_idx + 0] = lerped.x;
	output_buffer.data[out_idx + 1] = lerped.y;
	output_buffer.data[out_idx + 2] = lerped.z;
}
