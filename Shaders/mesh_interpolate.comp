#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

// Compute shader for interpolating alias model vertices (MDL/MD3)
// for acceleration structure building.
//
// Input: meshxyz_t vertex data (uint16 xyz[4] + int8 normal[4] = 12 bytes per vertex)
// Output: interpolated vec3 positions in model space
//
// The TLAS instance transform handles scale_origin, scale, and entity transform.

layout (push_constant) uniform PushConsts
{
	uint  pose1_offset;    // Offset in source buffer for pose1 (in vertices)
	uint  pose2_offset;    // Offset in source buffer for pose2 (in vertices)
	uint  output_offset;   // Offset in output buffer (in floats)
	uint  num_verts;
	float blend_factor;
	uint  flags;           // Bit 2: MD3 format
}
push_constants;

// meshxyz_t is 12 bytes: uint16[4] xyz + int8[4] normal
// We read as uints to get the data
layout (std430, set = 0, binding = 0) restrict readonly buffer InputVertices
{
	uint vertex_data[];
};

layout (std430, set = 0, binding = 2) restrict writeonly buffer OutputPositions
{
	float positions[];
};

// Decode a meshxyz_t vertex position to model-space coordinates
vec3 decode_vertex (uint offset)
{
	// Each meshxyz_t is 12 bytes = 3 uints
	// First 8 bytes (2 uints) contain xyz[4] as uint16
	uint xyz_low = vertex_data[offset * 3];
	uint xyz_high = vertex_data[offset * 3 + 1];

	// Extract uint16 values
	float x = float (xyz_low & 0xFFFF);
	float y = float (xyz_low >> 16);
	float z = float (xyz_high & 0xFFFF);

	// Normalize to [0, 1] then convert to model-space format
	const float norm = 1.0 / 65535.0;
	vec3 pos = vec3 (x, y, z) * norm;

	if ((push_constants.flags & 0x4) != 0)
	{
		// MD3: [0,1] -> [-32768, 32767] (raw format)
		pos = pos * 65535.0 - 32768.0;
	}
	else
	{
		// MDL: [0,1] -> [0, 255] (raw trivertx values)
		pos = pos * 255.0;
	}

	return pos;
}

layout (local_size_x = 64, local_size_y = 1) in;
void main ()
{
	uint vertex_idx = gl_GlobalInvocationID.x;
	if (vertex_idx >= push_constants.num_verts)
		return;

	vec3 pos1 = decode_vertex (push_constants.pose1_offset + vertex_idx);
	vec3 pos2 = decode_vertex (push_constants.pose2_offset + vertex_idx);

	vec3 lerped = mix (pos1, pos2, push_constants.blend_factor);

	uint out_idx = push_constants.output_offset + vertex_idx * 3;
	positions[out_idx + 0] = lerped.x;
	positions[out_idx + 1] = lerped.y;
	positions[out_idx + 2] = lerped.z;
}
